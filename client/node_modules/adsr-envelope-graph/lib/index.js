'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _phaseline;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var styles = {
    line: {
        fill: "none",
        stroke: 'rgb(221, 226, 232)',
        strokeWidth: "2"
    },
    timeline: {
        fill: "none",
        stroke: "#354550",
        strokeWidth: "1"
    },
    phaseline: (_phaseline = {
        fill: "none",
        stroke: "rgb(70, 94, 111)",
        strokeWidth: "1"
    }, _defineProperty(_phaseline, 'stroke', 'rgb(221, 226, 232)'), _defineProperty(_phaseline, 'strokeDasharray', '5,5'), _phaseline),
    background: {
        fill: "rgb(40, 56, 68)"
    }
};

var height = 100;
var width = 100;

var EnvelopeGraph = _react2.default.createClass({
    displayName: 'EnvelopeGraph',


    propTypes: {
        a: _react2.default.PropTypes.number.isRequired,
        d: _react2.default.PropTypes.number.isRequired,
        s: _react2.default.PropTypes.number.isRequired,
        r: _react2.default.PropTypes.number.isRequired,

        style: _react2.default.PropTypes.object,
        lineStyle: _react2.default.PropTypes.object,
        timeLineStyle: _react2.default.PropTypes.object,
        phaseLineStyle: _react2.default.PropTypes.object
    },

    /**
     * Returns the width of each phase
     * @return {Array} [attack_width, decay_width, sustain_width, release_width]
     */
    getPhaseLengths: function getPhaseLengths() {
        var total_time = this.props.a + this.props.d + this.props.r;

        //Percent of total envelope time (not counting sustain)
        var relative_a = this.props.a / total_time;
        var relative_d = this.props.d / total_time;
        var relative_r = this.props.r / total_time;

        //The sustain phase always has the same length
        var sustain_width = 10;
        var rem_width = width - sustain_width;

        //Distribute remaining width accoring to the relative lengths of each phase
        var absolute_a = relative_a * rem_width;
        var absolute_d = relative_d * rem_width;
        var absolute_r = relative_r * rem_width;

        return [absolute_a, absolute_d, sustain_width, absolute_r];
    },


    /**
     * Returns a string to be used as 'd' attribute on an svg path that resembles an envelope shape given its parameters
     * @return {String}
     */
    generatePath: function generatePath() {
        var _getPhaseLengths = this.getPhaseLengths(),
            _getPhaseLengths2 = _slicedToArray(_getPhaseLengths, 4),
            attack_width = _getPhaseLengths2[0],
            decay_width = _getPhaseLengths2[1],
            sustain_width = _getPhaseLengths2[2],
            release_width = _getPhaseLengths2[3];

        //Generate the svg path


        var strokes = [];
        strokes.push("M 0 " + height); //Start at the bottom

        strokes.push(this.linearStrokeTo(attack_width, -height));
        strokes.push(this.exponentialStrokeTo(decay_width, height * (1 - this.props.s)));
        strokes.push(this.linearStrokeTo(sustain_width, 0));
        strokes.push(this.exponentialStrokeTo(release_width, height * this.props.s));

        return strokes.join(" ");
    },


    /**
     * Constructs a command for an svg path that resembles an exponential curve
     * @param {Number} dx
     * @param {Number} dy
     * @return {String} command
     */
    exponentialStrokeTo: function exponentialStrokeTo(dx, dy) {
        return ["c", dx / 5, dy / 2, dx / 2, dy, dx, dy].join(" ");
    },


    /**
     * Constructs a line command for an svg path
     * @param {Number} dx
     * @param {Number} dy
     * @return {String} command
     */
    linearStrokeTo: function linearStrokeTo(dx, dy) {
        return "l " + dx + " " + dy;
    },
    render: function render() {
        return _react2.default.createElement(
            'svg',
            { style: this.props.style, viewBox: "0 0 100 100", preserveAspectRatio: 'none' },
            _react2.default.createElement('rect', { width: width, height: height, style: styles.background }),
            this.renderTimeLines(),
            _react2.default.createElement('path', { d: this.generatePath(), style: Object.assign({}, styles.line, this.props.lineStyle), vectorEffect: 'non-scaling-stroke' }),
            this.renderPhaseLines()
        );
    },


    /**
     * Renders a series of lines with exponentialy increasing distance between them
     */
    renderTimeLines: function renderTimeLines() {
        var total_time = this.props.a + this.props.d + this.props.r;

        var loglines = [];
        for (var i = 1e-6; i < 100; i = i * Math.E) {
            if (i > total_time) {
                break;
            }
            if (i / total_time > 1e-2) {
                loglines.push(_react2.default.createElement('line', {
                    key: i,
                    x1: i / total_time * width, y1: '0', x2: i / total_time * width, y2: height,
                    style: Object.assign({}, styles.timeline, this.props.timeLineStyle),
                    vectorEffect: 'non-scaling-stroke'
                }));
            }
        }

        return loglines;
    },


    /**
     * Renders a line between each phase
     */
    renderPhaseLines: function renderPhaseLines() {
        var widths = this.getPhaseLengths();

        var plines = [];
        var pos = 0;
        for (var i = 0; i < widths.length - 1; i++) {
            pos += widths[i];
            plines.push(_react2.default.createElement('line', {
                key: i,
                x1: pos, y1: '0', x2: pos, y2: height,
                style: Object.assign({}, styles.phaseline, this.props.phaseLineStyle),
                vectorEffect: 'non-scaling-stroke'
            }));
        }

        return plines;
    }
});

exports.default = EnvelopeGraph;