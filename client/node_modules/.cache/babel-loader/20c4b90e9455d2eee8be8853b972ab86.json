{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _phaseline;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar styles = {\n  line: {\n    fill: \"none\",\n    stroke: 'rgb(221, 226, 232)',\n    strokeWidth: \"2\"\n  },\n  timeline: {\n    fill: \"none\",\n    stroke: \"#354550\",\n    strokeWidth: \"1\"\n  },\n  phaseline: (_phaseline = {\n    fill: \"none\",\n    stroke: \"rgb(70, 94, 111)\",\n    strokeWidth: \"1\"\n  }, _defineProperty(_phaseline, 'stroke', 'rgb(221, 226, 232)'), _defineProperty(_phaseline, 'strokeDasharray', '5,5'), _phaseline),\n  background: {\n    fill: \"rgb(40, 56, 68)\"\n  }\n};\nvar height = 100;\nvar width = 100;\n\nvar EnvelopeGraph = _react2.default.createClass({\n  displayName: 'EnvelopeGraph',\n  propTypes: {\n    a: _react2.default.PropTypes.number.isRequired,\n    d: _react2.default.PropTypes.number.isRequired,\n    s: _react2.default.PropTypes.number.isRequired,\n    r: _react2.default.PropTypes.number.isRequired,\n    style: _react2.default.PropTypes.object,\n    lineStyle: _react2.default.PropTypes.object,\n    timeLineStyle: _react2.default.PropTypes.object,\n    phaseLineStyle: _react2.default.PropTypes.object\n  },\n\n  /**\n   * Returns the width of each phase\n   * @return {Array} [attack_width, decay_width, sustain_width, release_width]\n   */\n  getPhaseLengths: function getPhaseLengths() {\n    var total_time = this.props.a + this.props.d + this.props.r; //Percent of total envelope time (not counting sustain)\n\n    var relative_a = this.props.a / total_time;\n    var relative_d = this.props.d / total_time;\n    var relative_r = this.props.r / total_time; //The sustain phase always has the same length\n\n    var sustain_width = 10;\n    var rem_width = width - sustain_width; //Distribute remaining width accoring to the relative lengths of each phase\n\n    var absolute_a = relative_a * rem_width;\n    var absolute_d = relative_d * rem_width;\n    var absolute_r = relative_r * rem_width;\n    return [absolute_a, absolute_d, sustain_width, absolute_r];\n  },\n\n  /**\n   * Returns a string to be used as 'd' attribute on an svg path that resembles an envelope shape given its parameters\n   * @return {String}\n   */\n  generatePath: function generatePath() {\n    var _getPhaseLengths = this.getPhaseLengths(),\n        _getPhaseLengths2 = _slicedToArray(_getPhaseLengths, 4),\n        attack_width = _getPhaseLengths2[0],\n        decay_width = _getPhaseLengths2[1],\n        sustain_width = _getPhaseLengths2[2],\n        release_width = _getPhaseLengths2[3]; //Generate the svg path\n\n\n    var strokes = [];\n    strokes.push(\"M 0 \" + height); //Start at the bottom\n\n    strokes.push(this.linearStrokeTo(attack_width, -height));\n    strokes.push(this.exponentialStrokeTo(decay_width, height * (1 - this.props.s)));\n    strokes.push(this.linearStrokeTo(sustain_width, 0));\n    strokes.push(this.exponentialStrokeTo(release_width, height * this.props.s));\n    return strokes.join(\" \");\n  },\n\n  /**\n   * Constructs a command for an svg path that resembles an exponential curve\n   * @param {Number} dx\n   * @param {Number} dy\n   * @return {String} command\n   */\n  exponentialStrokeTo: function exponentialStrokeTo(dx, dy) {\n    return [\"c\", dx / 5, dy / 2, dx / 2, dy, dx, dy].join(\" \");\n  },\n\n  /**\n   * Constructs a line command for an svg path\n   * @param {Number} dx\n   * @param {Number} dy\n   * @return {String} command\n   */\n  linearStrokeTo: function linearStrokeTo(dx, dy) {\n    return \"l \" + dx + \" \" + dy;\n  },\n  render: function render() {\n    return _react2.default.createElement('svg', {\n      style: this.props.style,\n      viewBox: \"0 0 100 100\",\n      preserveAspectRatio: 'none'\n    }, _react2.default.createElement('rect', {\n      width: width,\n      height: height,\n      style: styles.background\n    }), this.renderTimeLines(), _react2.default.createElement('path', {\n      d: this.generatePath(),\n      style: Object.assign({}, styles.line, this.props.lineStyle),\n      vectorEffect: 'non-scaling-stroke'\n    }), this.renderPhaseLines());\n  },\n\n  /**\n   * Renders a series of lines with exponentialy increasing distance between them\n   */\n  renderTimeLines: function renderTimeLines() {\n    var total_time = this.props.a + this.props.d + this.props.r;\n    var loglines = [];\n\n    for (var i = 1e-6; i < 100; i = i * Math.E) {\n      if (i > total_time) {\n        break;\n      }\n\n      if (i / total_time > 1e-2) {\n        loglines.push(_react2.default.createElement('line', {\n          key: i,\n          x1: i / total_time * width,\n          y1: '0',\n          x2: i / total_time * width,\n          y2: height,\n          style: Object.assign({}, styles.timeline, this.props.timeLineStyle),\n          vectorEffect: 'non-scaling-stroke'\n        }));\n      }\n    }\n\n    return loglines;\n  },\n\n  /**\n   * Renders a line between each phase\n   */\n  renderPhaseLines: function renderPhaseLines() {\n    var widths = this.getPhaseLengths();\n    var plines = [];\n    var pos = 0;\n\n    for (var i = 0; i < widths.length - 1; i++) {\n      pos += widths[i];\n      plines.push(_react2.default.createElement('line', {\n        key: i,\n        x1: pos,\n        y1: '0',\n        x2: pos,\n        y2: height,\n        style: Object.assign({}, styles.phaseline, this.props.phaseLineStyle),\n        vectorEffect: 'non-scaling-stroke'\n      }));\n    }\n\n    return plines;\n  }\n});\n\nexports.default = EnvelopeGraph;","map":null,"metadata":{},"sourceType":"script"}